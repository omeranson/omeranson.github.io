---
layout: post
title: "ptrace magic: Redirect a running programme"
date: 2018-04-08
---

In this post I will show how to use ptrace to redirect the standard output of
a running programme.

# Rationale

Many times, I found myself running a programme, and having it spew its output
to the standard output to make sure it started properly. Usually things I
wrote that should run in the backgrounds, but are riddled with bugs.

Now it's running. I can send it to the background with CTRL+z and `bg`. But it
keeps being noisy, and it's difficult to work on the terminal. (Yes, I know
opening a new terminal is easy. That's not the point!)

So I wrote this little utility, that hacks into the daemon (or other process),
and overrides the given file descriptor with a new file {reword}.

It isn't very useful. But I found it slightly cool.

# High Level

The simplest API I could think of was a command line utility getting the PID
to connect to, the file descriptor to overwrite, and the file to overwrite the
file descriptor with:

```
./redirect: Usage: ./redirect <pid> <fd> <new outpath>
```

This API may need to be extended to include the flags of `open(2)`.

So basically, we connect to the target process with ptrace. We make it open
the file by calling `open(2)`. We override the file descriptor by calling
`dup2(2)`. And then we go have a beer.

Wait. Before the beer.

The code to do all of this has to run from within the context of the other
process. We can't code that directly. Additionally, `open(2)` needs a pointer
to the file name. That also has to be somewhere in the target process' memory
space.

So we need some place to put the code, and execute it. And we need some place
to put the file name, and point to it.

My solution was to use the code segment to store everything. `redirect` does
the following:

* Make a backup of the current code segment and registers. We're going to write
  both to the memory, and the registers. And we're going to want to revert all
  our changes.

* Copy over the filename. The start address is the instruction pointer. This
  way we already have the filename address, Everything is written to the same
  place, and it's easy.

* Overwrite the next instruction with the `syscall` instruction. Overwrite the
  instruction after that with the `int3` (debugger interrupt) instruction.

* Update the registers. These are used to pass parameters to the syscalls.

* Let the target process {define target process} run for a bit. It will do two instructions: syscall
  and interrupt. The interrupt will return control to the tracing process {define tracing process}.

  `ptrace` let's you take control of the target process when calling and returning
  from a syscall. The benefit of that solution is that you don't have to inject
  and catch the `int3` instruction.

* Revert what we did to the process. Restore the code segment and the registers.

This is a very simplistic implementation. It ignores memory permissions. i.e.
what if the code segment is not readable? (Actually, the kernel does the
reading, so it might work...)

It also ignores signal handling. This is not really an issue, since the tracing
process can capture all signals and block them for the target process until the
redirection is complete.

But this is the gist of it.


# Code

So now we can work through the code. The code itself is available
[here](https://github.com/omeranson/redirect), commit {XXX}.  Only
versions for 32-bit and 64-bit x86 exist. And the 32-bit version was
tested five years ago.

The `main` and `redirect_output_by_strings` functions are your run-of-the-mill
bad command line argument handling. I say bad, because usually I'm a firm believer
in `getopt`. Their goal is to parse the PID and file descriptor into integers,
and then call `redirect_output`.


```C
int redirect_output(pid_t pid, int fd, const char * outpath) {
```

The next block attaches to process with PID `pid`. 

```C
	rc = ptrace(PTRACE_ATTACH, pid, NULL, NULL);
	if (rc) {
		die("attach");
	}
	waitpid(pid);
```

The attached process (the tracee) is then sent a `SIGSTOP` signal. Once the
tracee actually stops ({why would this take time?}), the `waitpid` call will
return.

This code predates `PTRACE_SEIZE`, which is preferred due to some edge-cases.
Additionally, the tracee can be stopped without the use of signal by using
`ptrace(PTRACE_INTERRUPT, ...)`.

```C
	struct user_regs_struct regs;
	rc = ptrace(PTRACE_GETREGS, pid, NULL, &regs);
	if (rc) {
		die("getregs");
	}
```

Back up the current registers into the local variable `regs`.

```C
	size_t size = calculate_size(outpath);
	void * backup = malloc(size);
	addr = (void*)regs.rip;
	getdata(pid, addr, backup, size);
```

Back up the next `size` bytes in the code segment. `calculate_size` sums the
length of `outpath` (the command line argument), including its terminating NUL
character, and the size of the instructions we're going to inject.{Increases to word boundary}

`getdata` copies the `size` bytes of data from the tracee at address
`addr`, to the tracer at address `backup`. We'll see exactly how this is done
in a minute.

So in essence, we're copying some bytes from the code segment, just where the
tracee was about to execute.

I'll now digress and show `getdata` and `putdata`. These are helper functions
to copy from and to the tracee.

```C
void getdata(pid_t child, const word_t * addr, void *str, int len) {
```

We'll tackle `getdata` in two parts. In both cases, we use `PTRACE_PEEKDATA`,
which copies over exactly a _word_. Turns out that's four bytes, but just in
case that ever changes, we defined it:

```C
typedef uint32_t word_t;
#define word_size sizeof(word_t)
```

Why is that important? Because not all sizes are divisible by 4. 21, for
instance.

So the first part of 
```C
	int i;
	int j = len / word_size;
	for (i = 0; i < j; i++) {
		*str++ = ptrace(PTRACE_PEEKDATA, child, addr++, NULL);
	}
```



* getdata


# Conclusion

# References
